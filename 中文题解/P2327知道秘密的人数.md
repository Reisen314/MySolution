# Problem: 2327. 知道秘密的人数


## 思路

双端队列

ans_list:双端队列deque()，表示当前知道秘密的人，第n-i个元素表示i天前这一天知道秘密的人数，注意deque有个maxlen参数可以规定这个双端队列的最大长度，达到最大长度继续append新元素会自动“挤掉”最左边元素，符合我们当前的应用场景

## 解题过程

实际编写时，可以分两个队列一个存储当前知道秘密的人，另一个存储delay期内的人（还没开始传播），方便更新第二天传播人数

## 复杂度

### 时间复杂度: 
O(n)


### 空间复杂度: 
O(1)




## Code
只用一个deque的版本
```Python

class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        #初始化一个deque
        ans_list=deque(maxlen=forget)
        initial=[0]*forget
        ans_list.extend(initial)
        curr_sum=0
        ans_list.append(1)
        for i in range(1,n):
            curr_sum-=ans_list[0]
            #这一步复杂度似乎是o(n)
            curr_sum+=ans_list[forget-delay]
            ans_list.append(curr_sum)
            
        return (sum(ans_list)%(1000_000_007))
        
```





两个deque
```Python


class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        #初始化两个双端队列，设置maxlen参数会在“放不下”时自动popleft
        ans_list=deque(maxlen=forget)
        ans_list.extend([0]*forget)
        delay_list=deque(maxlen=delay)
        delay_list.extend([0]*delay)
        curr_sum=0
        ans_list.append(1)
        delay_list.append(1)
        for i in range(1,n):
            #更新当前知道秘密的人数
            curr_sum-=ans_list[0]
            curr_sum+=delay_list[0]
            #塞进两个列表
            ans_list.append(curr_sum)
            delay_list.append(curr_sum)
            
        return (sum(ans_list)%(1000_000_007))
        

```

## 总结
使用双端队列这个数据结构可以很好的刻画“传播”“遗忘”的过程
本质上可以看成是一个数列问题(或者离散动力系统问题?)：
$$
\mathbf{X}_{n}  
= \mathbf{X}_{n-p} + \mathbf{X}_{n-p+1} + \cdots + \mathbf{X}_{n-q}
$$
其中$0<q<p<n$
如果p=2,q=1,就变成了我们熟知的斐波那契数列

$$
\mathbf{X}_{n}  
= \mathbf{X}_{n-2} + \mathbf{X}_{n-1}
$$





